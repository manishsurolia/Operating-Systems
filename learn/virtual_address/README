'readelf' utility can help us to understand the way things are stored in a
program when it is executed.

Compiler tool chain "by default" creates a program(executable) assuming that,
this program is going to load the address '0x0' of RAM.

Hence, all the addresses for each function and global data, are used in the
executable, after considering this fact.

If you compile the code for 'memory-user.c' and run readelf utility on the same,
you will find the address for function 'main' something similar as below:

[ ] readelf -s a.out  | grep main
    66: 00000000000013b0    92 FUNC    GLOBAL DEFAULT   16 main

The address here, depicts that the function 'main' will be stored at the address
'00000000000013b0' physical address, when program loads in the memory.

But, in linux, during load of a program, OS finds an appropriate place in RAM
for any process(like how malloc does when we allocate dynamic memory), and loads
it and sets the base address (in MMU) for this process to the address where this
program has been loaded.

So, these addresses, which are generated by linker are actually virtual
addresses.

Hence, there the address of 'main' above is a virtual address.

When this program gets executed and access these addresses by instructions, MMU
converts these addresses as below:

Physical Address = Base Address + Virtual address

Now, lets compile and run this program 'memory-user.c'.

[ ] gcc memory-user.c
[ ] ./a.out 
Address of main function : 0x55a2166e33b0
(Process Base Address + offset) : 0x55a2166e2000+0x13b0

Now, at the same time open another terminal, and run one more instance of the
same program.

[ ] ./a.out 
Address of main function : 0x55b7792623b0
(Process Base Address + offset) : 0x55b779261000+0x13b0

If you notice here, when 2 or more instances of the same program is running, the
virtual address, generated by linker remains same(same as what readelf showed
us) and the base address is different.

Conclusion : 
------------

When linux loads a program in memory, it loads this at a suitable place in RAM,
and all the addresses in the executable are actually virtual addresses, which
are converted to actual Physical address by MMU of the hardware when these
addresses are used by CPU instructions.
